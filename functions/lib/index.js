"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transcribeAudioFile = exports.uploadAudioFile = exports.generateDiagnosis = exports.extractMedicalInfo = exports.transcribeAudio = exports.helloWorld = void 0;
// API v2
const https_1 = require("firebase-functions/v2/https");
const options_1 = require("firebase-functions/v2/options");
const gemini_service_1 = require("./services/gemini.service");
const transcription_service_1 = require("./services/transcription.service");
const upload_service_1 = require("./services/upload.service");
// Define regi√£o padr√£o (S√£o Paulo) e, se quiser, limites globais
(0, options_1.setGlobalOptions)({
    region: "southamerica-east1",
    // memory: "256MiB", // Limite de mem√≥ria
    // timeoutSeconds: 60, // Timeout padr√£o
});
// Fun√ß√£o de teste
exports.helloWorld = (0, https_1.onRequest)((req, res) => {
    res.json({ message: 'Hello from Firebase Functions!' });
});
// Fun√ß√£o de transcri√ß√£o usando o servi√ßo real
exports.transcribeAudio = (0, https_1.onRequest)(async (req, res) => {
    try {
        const { audioUrl } = req.body;
        if (!audioUrl) {
            res.status(400).json({ error: 'URL do √°udio √© obrigat√≥ria' });
            return;
        }
        console.log(`üéµ Recebida solicita√ß√£o de transcri√ß√£o para: ${audioUrl}`);
        // Usar o servi√ßo de transcri√ß√£o
        const transcriptionService = new transcription_service_1.TranscriptionService();
        const result = await transcriptionService.transcribeAudio(audioUrl);
        console.log(`‚úÖ Transcri√ß√£o conclu√≠da com sucesso. Confian√ßa: ${result.confidence}`);
        res.json({
            transcription: result.transcription,
            confidence: result.confidence,
            language: result.language,
            duration: result.duration,
            audioUrl: audioUrl
        });
    }
    catch (error) {
        console.error('‚ùå Erro na transcri√ß√£o:', error);
        // Tratar erros espec√≠ficos
        if (error.message.includes('URL deve usar HTTP ou HTTPS')) {
            res.status(400).json({ error: 'URL deve usar HTTP ou HTTPS' });
        }
        else if (error.message.includes('Formato n√£o suportado')) {
            res.status(400).json({ error: error.message });
        }
        else if (error.message.includes('URL inv√°lida')) {
            res.status(400).json({ error: 'URL inv√°lida' });
        }
        else {
            res.status(500).json({ error: 'Erro interno do servidor na transcri√ß√£o' });
        }
    }
});
// Fun√ß√£o de extra√ß√£o de informa√ß√µes m√©dicas usando Gemini
exports.extractMedicalInfo = (0, https_1.onRequest)(async (req, res) => {
    try {
        const { text } = req.body;
        if (!text || typeof text !== 'string') {
            res.status(400).json({ error: 'Texto √© obrigat√≥rio' });
            return;
        }
        // Validar tamanho do texto
        if (text.length > 5000) {
            res.status(400).json({ error: 'Texto muito longo. M√°ximo 5000 caracteres.' });
            return;
        }
        // Usar o servi√ßo Gemini para extrair informa√ß√µes
        const geminiService = new gemini_service_1.GeminiService();
        const extractedInfo = await geminiService.extractMedicalInfo(text);
        res.json(extractedInfo);
    }
    catch (error) {
        console.error('Erro na extra√ß√£o de informa√ß√µes m√©dicas:', error);
        // Tratar erros espec√≠ficos
        if (error.message.includes('GEMINI_API_KEY')) {
            res.status(500).json({
                error: 'Servi√ßo de IA n√£o configurado. Entre em contato com o administrador.'
            });
        }
        else if (error.message.includes('JSON v√°lido')) {
            res.status(500).json({
                error: 'Erro no processamento da resposta da IA. Tente novamente.'
            });
        }
        else {
            res.status(500).json({
                error: 'Erro interno do servidor na extra√ß√£o de informa√ß√µes m√©dicas'
            });
        }
    }
});
// Fun√ß√£o de gera√ß√£o de diagn√≥stico usando Gemini
exports.generateDiagnosis = (0, https_1.onRequest)(async (req, res) => {
    var _a;
    try {
        const medicalData = req.body;
        if (!medicalData) {
            res.status(400).json({ error: 'Dados m√©dicos s√£o obrigat√≥rios' });
            return;
        }
        console.log(`üß† Recebida solicita√ß√£o de diagn√≥stico para paciente: ${((_a = medicalData.patient) === null || _a === void 0 ? void 0 : _a.name) || 'N/A'}`);
        // Usar o Gemini para gerar diagn√≥stico
        const geminiService = new gemini_service_1.GeminiService();
        const diagnosis = await geminiService.generateDiagnosis(medicalData);
        console.log(`‚úÖ Diagn√≥stico gerado com sucesso`);
        res.json({
            result: diagnosis,
            timestamp: new Date().toISOString()
        });
    }
    catch (error) {
        console.error('‚ùå Erro na gera√ß√£o de diagn√≥stico:', error);
        // Tratar erros espec√≠ficos
        if (error.message.includes('GEMINI_API_KEY')) {
            res.status(500).json({
                error: 'Servi√ßo de IA n√£o configurado. Entre em contato com o administrador.'
            });
        }
        else {
            res.status(500).json({ error: 'Erro interno do servidor na gera√ß√£o de diagn√≥stico' });
        }
    }
});
// Fun√ß√£o de upload de arquivo de √°udio
exports.uploadAudioFile = (0, https_1.onRequest)(async (req, res) => {
    try {
        if (!req.files || !req.files.file) {
            res.status(400).json({ error: 'Nenhum arquivo de √°udio enviado' });
            return;
        }
        const audioFile = req.files.file;
        console.log(`üì§ Recebido arquivo: ${audioFile.originalname} (${audioFile.size} bytes)`);
        // Fazer upload para Firebase Storage
        const uploadService = new upload_service_1.UploadService();
        const uploadResult = await uploadService.uploadAudioFile(audioFile.buffer, audioFile.originalname, audioFile.mimetype);
        console.log(`‚úÖ Upload conclu√≠do: ${uploadResult.url}`);
        res.json({
            success: true,
            file: uploadResult,
            message: 'Arquivo enviado com sucesso'
        });
    }
    catch (error) {
        console.error('‚ùå Erro no upload:', error);
        res.status(500).json({ error: 'Erro interno do servidor no upload' });
    }
});
// Fun√ß√£o de transcri√ß√£o de arquivo de √°udio direto
exports.transcribeAudioFile = (0, https_1.onRequest)(async (req, res) => {
    try {
        // Debug: ver o que est√° chegando
        console.log('üîç Debug - req.method:', req.method);
        console.log('üîç Debug - req.headers:', req.headers);
        console.log('üîç Debug - req.body:', req.body);
        // Verificar se temos os dados do arquivo
        if (!req.body || !req.body.data) {
            console.log('‚ùå Dados n√£o encontrados no body');
            res.status(400).json({ error: 'Dados n√£o encontrados' });
            return;
        }
        const { filename, contentType, size, data } = req.body;
        // Detectar se √© URL ou arquivo base64
        if (data.startsWith('http')) {
            console.log('üåê Processando URL de √°udio:', data);
            await processAudioUrl(data, res);
        }
        else {
            console.log(`üéµ Recebido arquivo: ${filename} (${size} bytes)`);
            await processAudioFile(data, filename, contentType, size, res);
        }
    }
    catch (error) {
        console.error('‚ùå Erro na transcri√ß√£o:', error);
        res.status(500).json({ error: 'Erro interno do servidor na transcri√ß√£o' });
    }
});
// Fun√ß√£o para processar URL de √°udio
async function processAudioUrl(audioUrl, res) {
    try {
        console.log('üéØ Baixando √°udio da URL:', audioUrl);
        // Fazer download do arquivo
        const https = require('https');
        const http = require('http');
        const protocol = audioUrl.startsWith('https') ? https : http;
        const audioBuffer = await new Promise((resolve, reject) => {
            protocol.get(audioUrl, (response) => {
                if (response.statusCode !== 200) {
                    reject(new Error(`HTTP ${response.statusCode}: ${response.statusMessage}`));
                    return;
                }
                const chunks = [];
                response.on('data', (chunk) => chunks.push(chunk));
                response.on('end', () => resolve(Buffer.concat(chunks)));
                response.on('error', reject);
            }).on('error', reject);
        });
        console.log(`‚úÖ Download conclu√≠do: ${audioBuffer.length} bytes`);
        // Processar o arquivo baixado
        await processAudioFile(audioBuffer.toString('base64'), 'audio_from_url', 'audio/mp4', audioBuffer.length, res);
    }
    catch (error) {
        console.error('‚ùå Erro no download da URL:', error);
        res.status(500).json({ error: `Erro ao baixar √°udio da URL: ${error.message}` });
    }
}
// Fun√ß√£o para processar arquivo de √°udio
async function processAudioFile(data, filename, contentType, size, res) {
    try {
        // Converter base64 para buffer
        const audioBuffer = Buffer.from(data, 'base64');
        // SOLU√á√ÉO ALTERNATIVA: Usar Google Speech-to-Text diretamente com dados base64
        try {
            console.log('üéØ Tentando transcri√ß√£o direta com Google Speech-to-Text...');
            const transcriptionService = new transcription_service_1.TranscriptionService();
            console.log('‚úÖ TranscriptionService criado com sucesso');
            // Criar um arquivo tempor√°rio local para o Google Speech-to-Text
            const os = require('os');
            const tempDir = os.tmpdir(); // Pega o diret√≥rio tempor√°rio correto do sistema
            const tempFilePath = require('path').join(tempDir, `audio_${Date.now()}_${filename}`);
            console.log('üìÅ Criando arquivo tempor√°rio:', tempFilePath);
            console.log('üìÅ Diret√≥rio tempor√°rio do sistema:', tempDir);
            try {
                require('fs').writeFileSync(tempFilePath, audioBuffer);
                console.log('‚úÖ Arquivo tempor√°rio criado com sucesso');
                // Verificar se o arquivo foi criado
                const fs = require('fs');
                if (fs.existsSync(tempFilePath)) {
                    console.log('‚úÖ Arquivo tempor√°rio existe e pode ser lido');
                    const stats = fs.statSync(tempFilePath);
                    console.log('üìä Tamanho do arquivo tempor√°rio:', stats.size, 'bytes');
                }
                else {
                    console.log('‚ùå Arquivo tempor√°rio n√£o foi criado');
                }
            }
            catch (fileError) {
                console.error('‚ùå Erro ao criar arquivo tempor√°rio:', fileError);
                throw fileError;
            }
            // Usar o servi√ßo de transcri√ß√£o com arquivo local
            console.log('üéµ Chamando transcribeLocalFile...');
            const transcriptionResult = await transcriptionService.transcribeLocalFile(tempFilePath);
            console.log('‚úÖ transcribeLocalFile retornou:', transcriptionResult);
            // Limpar arquivo tempor√°rio
            try {
                require('fs').unlinkSync(tempFilePath);
                console.log('‚úÖ Arquivo tempor√°rio removido');
            }
            catch (cleanupError) {
                console.error('‚ö†Ô∏è Erro ao remover arquivo tempor√°rio:', cleanupError);
            }
            console.log(`‚úÖ Transcri√ß√£o direta conclu√≠da com sucesso`);
            res.json({
                success: true,
                transcription: transcriptionResult.transcription,
                confidence: transcriptionResult.confidence,
                language: transcriptionResult.language,
                message: 'Transcri√ß√£o conclu√≠da com sucesso'
            });
        }
        catch (transcriptionError) {
            console.log('‚ö†Ô∏è Transcri√ß√£o direta falhou, usando fallback...');
            console.error('‚ùå Erro detalhado:', transcriptionError);
            console.error('‚ùå Stack trace:', transcriptionError.stack);
            // FALLBACK: Transcri√ß√£o mock para desenvolvimento
            const mockTranscription = `[TRANSCRI√á√ÉO MOCK] Arquivo de √°udio "${filename}" recebido com sucesso. 
      Tamanho: ${size} bytes. 
      Tipo: ${contentType}.
      
      Para transcri√ß√£o real, configure o Firebase Storage ou use um arquivo de √°udio compat√≠vel com Google Speech-to-Text.`;
            res.json({
                success: true,
                transcription: mockTranscription,
                confidence: 0.95,
                language: 'pt-BR',
                message: 'Transcri√ß√£o mock (configure Storage para transcri√ß√£o real)'
            });
        }
    }
    catch (error) {
        console.error('‚ùå Erro no processamento do arquivo:', error);
        res.status(500).json({ error: `Erro ao processar arquivo: ${error.message}` });
    }
}
//# sourceMappingURL=index.js.map